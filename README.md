# OAuth 

## 目录
- 1. Roles: Applications, APIs and Users
- 2. Creating an App
- 3. Authorization: Obtaining an access token
  - 3.1 Web Server Apps
  - 3.2 Single-Page Apps
  - 3.3 Mobile Apps
  - 3.4 Other Grant Types
- 4. Making Authenticated Requests

## 1. 角色 Roles: Applications, APIs and Users

**Client**  应用程序 Applications

第三方应用程序，它需要访问用户账号。它必须提前获得许可。

**Resource Server** 资源服务器

保存用户可访问信息的API服务器。

**The Authorization Server** 授权服务器

提供用户许可或者拒绝请求的界面。

**Resource Owner** Users 资源拥有者

用户，资源所有者，他允许自己账号的部分资源被访问。

## 2. 创建应用 Creating an App

在OAuth过程开始之前，必须在服务里注册这个app。 注册新的app时，需要提供的基本信息包括：应用名称，网址，logo以及一个redirect URI来重定向用户。

**Redirect URIs** 重定向地址

服务仅会重定向用户到注册过的一个URI，以避免攻击。
任何redirect URIs必须被TLS保护，所以服务金辉重定向到`https`开头的URI。
这可以防止在授权过程中token被截取。

Native apps may register a redirect URI with a custom URL scheme for the application, which may look like demoapp://redirect.

**Client ID and Secret**

注册完应用以后，会获得一个client ID 和一个client secret。

- **client ID** 是公开信息，用来构建登录地址，或被页面里面的js代码所引用。
- **client secret** 必须保密，如果一个应用不能保证保密，比如SPA或原生应用，这时就不使用secret。 理想情况下，一开始服务就不应该将secrect发给这些应用。

## 3. 授权过程：获取一个访问token

The first step of OAuth 2 is to get authorization from the user. For browser-based or mobile apps, this is usually accomplished by displaying an interface provided by the service to the user.

OAuth 2 provides several "grant types" for different use cases. The grant types defined are:

- **Authorization Code** for apps running on a web server, browser-based and mobile apps
- **Password** for logging in with a username and password
- **Client credentials** for application access
- **Implicit** was previously recommended for clients without a secret, but has been superceded by using the Authorization Code grant with no secret.
Each use case is described in detail below.

### 3.1 Web Server Apps

Web server apps are the most common type of application you encounter when dealing with OAuth servers. Web apps are written in a server-side language and run on a server where the source code of the application is not available to the public. This means the application is able to use its client secret when communicating with the authorization server, which can help avoid some attack vectors.

**Authorization**

Create a "Log In" link sending the user to:

`https://oauth2server.com/auth?response_type=code&
  client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=photos&state=1234zyx`

- **code** - Indicates that your server expects to receive an authorization code
- **client_id** - The client ID you received when you first created the application
- **redirect_uri** - Indicates the URI to return the user to after authorization is complete
- **scope** - One or more scope values indicating which parts of the user's account you wish to access
- **state** - A random string generated by your application, which you'll verify later

The user sees the authorization prompt

![OAuth Authorization Prompt](imgs/oauth-authorization-prompt.png)


If the user clicks "Allow," the service redirects the user back to your site with an auth code

`https://oauth2client.com/cb?code=AUTH_CODE_HERE&state=1234zyx`

- **code** - The server returns the authorization code in the query string
- **state** - The server returns the same state value that you passed

You should first compare this state value to ensure it matches the one you started with. You can typically store the state value in a cookie or session, and compare it when the user comes back. This ensures your redirection endpoint isn't able to be tricked into attempting to exchange arbitrary authorization codes.

**Token Exchange**

Your server exchanges the auth code for an access token:

`POST https://api.oauth2server.com/token
  grant_type=authorization_code&
  code=AUTH_CODE_HERE&
  redirect_uri=REDIRECT_URI&
  client_id=CLIENT_ID&
  client_secret=CLIENT_SECRET`

- **grant_type=authorization_code** - The grant type for this flow is authorization_code
- **code=AUTH_CODE_HERE** - This is the code you received in the query string
- **redirect_uri=REDIRECT_URI** - Must be identical to the redirect URI provided in the original link
- **client_id=CLIENT_ID** - The client ID you received when you first created the application
- **client_secret=CLIENT_SECRET** - Since this request is made from server-side code, the secret is included

The server replies with an access token and expiration time

```
{
  "access_token":"RsT5OjbzRn430zqMLgV3Ia",
  "expires_in":3600
}
```

or if there was an error

```
{
  "error":"invalid_request"
}
```

Security: Note that the service must require apps to pre-register their redirect URIs.


### 3.2 Single-Page Apps

Single-page apps (or browser-based apps) run entirely in the browser after loading the source code from a web page. Since the entire source code is available to the browser, they cannot maintain the confidentiality of their client secret, so the secret is not used in this case. The flow is exactly the same as the authorization code flow above, but at the last step, the authorization code is exchanged for an access token without using the client secret.

**Authorization**

Create a "Log In" link sending the user to:

`https://oauth2server.com/auth?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=photos&state=1234zyx`

- **code** - Indicates that your server expects to receive an authorization code
- **client_id** - The client ID you received when you first created the application
- **redirect_uri** - Indicates the URI to return the user to after authorization is complete
- **scope** - One or more scope values indicating which parts of the user's account you wish to access
- **state** - A random string generated by your application, which you'll verify later

The user sees the authorization prompt

![OAuth Authorization Prompt](imgs/oauth-authorization-prompt.png)

If the user clicks "Allow," the service redirects the user back to your site with an auth code

`https://oauth2client.com/cb?code=AUTH_CODE_HERE&state=1234zyx`

- **code** - The server returns the authorization code in the query string
- **state** - The server returns the same state value that you passed

You should first compare this state value to ensure it matches the one you started with. You can typically store the state value in a cookie, and compare it when the user comes back. This ensures your redirection endpoint isn't able to be tricked into attempting to exchange arbitrary authorization codes.

**Token Exchange**

```
POST https://api.oauth2server.com/token
  grant_type=authorization_code&
  code=AUTH_CODE_HERE&
  redirect_uri=REDIRECT_URI&
  client_id=CLIENT_ID
```

- **grant_type=authorization_code** - The grant type for this flow is authorization_code
- **code=AUTH_CODE_HERE** - This is the code you received in the query string
- **redirect_uri=REDIRECT_URI** - Must be identical to the redirect URI provided in the original link
- **client_id=CLIENT_ID** - The client ID you received when you first created the application


### 3.3 Mobile Apps

Like browser-based apps, mobile apps also cannot maintain the confidentiality of their client secret. Because of this, mobile apps must also use an OAuth flow that does not require a client secret. There are some additional concerns that mobile apps should keep in mind to ensure the security of the OAuth flow.

**Authorization**

Create a "Log in" button sending the user to either the native app of the service on the phone, or a mobile web page for the service. On iPhone, apps can register a custom URI protocol such as "facebook://" so the native Facebook app is launched whenever a URL with that protocol is visited. On Android, apps can register URL matching patterns which will launch the native app if a URL matching the pattern is visited.

**Using the Service's Native App**

If the user has the native Facebook app installed, direct them to the following URL:

`fbauth2://authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=email&state=1234zyx`

- **response_type=code** - indicates that your server expects to receive an authorization code
- **client_id=CLIENT_ID** - The client ID you received when you first created the application
- **redirect_uri=REDIRECT_URI** - Indicates the URI to return the user to after authorization is complete, such as fb00000000://authorize
- **scope=email** - One or more scope values indicating which parts of the user's account you wish to access
- **state=1234zyx** - A random string generated by your application, which you'll verify later

For servers that support the PKCE extension (and if you're building a server, you should support the PKCE extension), you'll also include the following parameters. First, create a "code verifier" which is a random string that the app stores locally.

- **code_challenge=XXXXXXX** - This is a base64-encoded version of the sha256 hash of the code verifier string
- **code_challenge_method=S256** - Indicates the hashing method used to compute the challenge, in this case, sha256.
Note that your redirect URI will probably look like fb00000000://authorize where the protocol is a custom URL scheme that your app has registered with the OS.

**Using a Web Browser**

If the service does not have a native application, you can launch a mobile browser to the standard web authorization URL. Note that you should never use an embedded web view in your own application, as this provides the user no guarantee that they are actually are entering their password in the service's website rather than a phishing site.

You should either launch the native mobile browser, or use the new iOS "SafariViewController" to launch an embedded browser in your application. This API was added in iOS 9, and provides a mechanism to launch a browser inside the application that both shows the address bar so the user can confirm they're on the correct website, and also shares cookies with the real Safari browser. It also prevents the application from inspecting and modifying the contents of the browser, so can be considered secure.

`https://facebook.com/dialog/oauth?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=email&state=1234zyx`

Again, if the service supports PKCE, then those parameters should be included as well as described above.

- **response_type=code** - indicates that your server expects to receive an authorization code
- **client_id=CLIENT_ID** - The client ID you received when you first created the application
- **redirect_uri=REDIRECT_URI** - Indicates the URI to return the user to after authorization is complete, such as fb00000000://authorize
- **scope=email** - One or more scope values indicating which parts of the user's account you wish to access
- **state=1234zyx** - A random string generated by your application, which you'll verify later
The user will see the authorization prompt

![Facebook Authorization Prompt](imgs/everyday-city-auth.png)

**Token Exchange**

After clicking "Approve", the user will be redirected back to your application with a URL like

`fb00000000://authorize#code=AUTHORIZATION_CODE&state=1234zyx`

Your mobile application should first verify that the state corresponds to the state that was used in the initial request, and can then exchange the authorization code for an access token.

The token exchange will look the same as exchanging the code in the web server app case, except that the secret is not sent. If the server supports PKCE, then you will need to include an additional parameter as described below.

`POST https://api.oauth2server.com/token
  grant_type=authorization_code&
  code=AUTH_CODE_HERE&
  redirect_uri=REDIRECT_URI&
  client_id=CLIENT_ID&
  code_verifier=VERIFIER_STRING`

- **grant_type=authorization_code** - The grant type for this flow is authorization_code
- **code=AUTH_CODE_HERE** - This is the code you received in the query string
- **redirect_uri=REDIRECT_URI** - Must be identical to the redirect URI provided in the original link
- **client_id=CLIENT_ID** - The client ID you received when you first created the application
- **code_verifier=VERIFIER_STRING** - The plaintext string that you previously hashed to create the code_challenge

The authorization server will verify this request and return an access token.

If the server supports PKCE, then the authorization server will recognize that this code was generated with a code challenge, and will hash the provided plaintext and confirm that the hashed version corresponds with the hashed string that was sent in the initial authorization request. This ensures the security of using the authorization code flow with clients that don't support a secret.

### 3.4 Other Grant Types

**Password**

OAuth 2 also provides a "password" grant type which can be used to exchange a username and password for an access token directly. Since this obviously requires the application to collect the user's password, it must only be used by apps created by the service itself. For example, the native Twitter app could use this grant type to log in on mobile or desktop apps.

To use the password grant type, simply make a POST request like the following:

```
POST https://api.oauth2server.com/token
  grant_type=password&
  username=USERNAME&
  password=PASSWORD&
  client_id=CLIENT_ID
```

- **grant_type=password** - The grant type for this flow is password
- **username=USERNAME** - The user's username as collected by the application
- **password=PASSWORD** - The user's password as collected by the application
- **client_id=CLIENT_ID** - The client ID you received when you first created the application

The server replies with an access token in the same format as the other grant types.

Note, the client secret is not included here under the assumption that most of the use cases for password grants will be mobile or desktop apps, where the secret cannot be protected.

**Application access**

In some cases, applications may need an access token to act on behalf of themselves rather than a user. For example, the service may provide a way for the application to update their own information such as their website URL or icon, or they may wish to get statistics about the users of the app. In this case, applications need a way to get an access token for their own account, outside the context of any specific user. OAuth provides the client_credentials grant type for this purpose.

To use the client credentials grant type, make a POST request like the following:

```
POST https://api.oauth2server.com/token
    grant_type=client_credentials&
    client_id=CLIENT_ID&
    client_secret=CLIENT_SECRET
```

The response will include an access token in the same format as the other grant types.


## 4. 进行被授权请求 Making Authenticated Requests

所有的授权类型的结果都是获得一个access token，这时便可以使用这个token访问API。

使用curl进行访问示例如下：

`curl -H "Authorization: Bearer RsT5OjbzRn430zqMLgV3Ia" https://api.oauth2server.com/1/me`

确保永远使用https提交请求，https是唯一确保请求不被截取或者修改的方法。

## 词汇表

- authorization 授权